---
title: 'Intro to the Tidyverse: R-Ladies SB May 2019'
author: "Sam Csik & An Bui"
date: "15 May 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **What is the tidyverse?**

The tidyverse is a collection of R packages designed for data science that share an underlying design philosophy, grammar, and data structures. Using the tidyverse can help to streamline your data manipulation and visualisations (and make this often-daunting process actually enjoyable). [Read more about it here!](https://www.tidyverse.org/) 

## **What packages are in the tidyverse?**

| package | usage | primary functions 
|-----------|-----------------------------------------|---------------------------------------------------------| 
| [ggplot2](https://ggplot2.tidyverse.org/) | create graphics | too much to cover here, but we recommend reviewing [Ch 3: Data visualisation](https://r4ds.had.co.nz/data-visualisation.html) in R for Data Science (Wickam & Grolemund 2017)
| [dplyr](https://dplyr.tidyverse.org/) | data maniupulation | mutate(), filter(), select(), summarize(), arrange(), group_by()
| [tidyr](https://tidyr.tidyverse.org/) | transform data to tidy format | gather(), spread()
| [readr](https://readr.tidyverse.org/) | read in rectangular data (e.g. csv) | read_csv()
| [purrr](https://purrr.tidyverse.org/) | facilitates work with functions & vectors | map()
| [tibble](https://tibble.tidyverse.org/) | create tibbles (modernized data frames) | as_tibble(), tibble(), tribble()
| [stringr](https://stringr.tidyverse.org/) | facilitates work with strings | str_detect, str_count, str_subset(), str_locate(), str_extract(), str_match(), str_replace(), str_split()
| [forcats](https://forcats.tidyverse.org/) | facilitates work with categorical variables | fct_reorder(), fct_infreq(), fct_relevel(), fct_lump()
| [magrittr](https://magrittr.tidyverse.org/) | facilitates sequential modification of a data frame | %>% 

## **Don't have the tidyverse yet?**
### Install using the following code:

```{r, eval = FALSE}
install.packages("tidyverse")
```

### Load the tidyverse:

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

## **Tidyverse & data wrangling functions cheat sheet:**

Below are reproducible examples of commonly used tidyverse functions.

**Remember:** you can string together multiple functions using the pipe operator **%>%**. R will evaluate the current function based off the the results of prior function calls.

Let's first create some completely hypothetical data about the number of pizzas eaten by Sam, An, Allison, Julie, and Jamie over the past 3 years :)
```{r}
# NOTE: this data is untidy (i.e. in wide format, where each row represents three observations, not one)
pizza_data <- tribble(
  ~name,    ~'2017',   ~'2018',   ~'2019',
  "Sam",       25,        20,        16,
  "An",        20,        15,        11,
  "Allison",   18,        17,        10,
  "Julie",     19,        10,        14,
  "Jamie",     21,        13,        14
  )
```

We'll first want to transform 'pizza_data' into tidy (long) format:

**gather():** transforms data from wide to long format
```{r}
tidy_pizza <- pizza_data %>% 
  gather('2017', '2018', '2019', key = "year", value = "pizzas_eaten")
```

Now let's use our tidy data to practice some further wrangling.

**arrange():** order observations as specified (default = alphabetical or ascending)
```{r}
ordered_names <- tidy_pizza %>% 
  arrange(name) # for descending alphabetical order, use "arrange(desc(names))"

ordered_num_pizzas <- tidy_pizza %>% 
  arrange(pizzas_eaten) # for descending order, use "arrange(-pizzas_eaten)"
```

**filter():** select observations within columns
```{r}
sam_an <- tidy_pizza %>% 
  filter(name == "Sam" | name == "An") # "|" tells R to filter any observations that match "Sam" OR "An"
```

**group_by():** groups observations such that data operations are performed at the level of the group
```{r}
grouped_names <- tidy_pizza %>% 
  group_by(name) # notice that nothing appears to change when you view 'grouped_df.' See the summarize() function below for further example.
```

**mutate():** 
```{r}
# use mutate() to coerce a variable to a different data type
name_as_factor <- tidy_pizza %>% 
  mutate(name = as.factor(name)) # you can check that this worked by viewing 'str(name_as_factor)'

# use mutate() to calculate a new value using existing observations and add this new value to a new column
pizzas_per_month <- tidy_pizza %>% 
  mutate(pizzas_per_month = pizzas_eaten/12)

# use mutate in conjunction with case_when to add a column based off existing observations
fav_pizza <- tidy_pizza %>% 
  mutate(
    fav_pizza = case_when(
      name == "Sam" ~ "Buffalo Chicken",
      name == "An" ~ "Pepperoni",
      name == "Allison" ~ "Cheese",
      name == "Julie" ~ "Margherita",
      name == "Jamie" ~ "Veggie"
    )
  )

# use mutate in conjunction with ifelse, where if the observation in the 'name' column matches "Sam," report "1". If not, report "0"
binary <- tidy_pizza %>% 
  mutate(binary = ifelse(name == "Sam", "1", "0")) 
```

**pull():** pulls out a single variable from a df and saves it as a vector
```{r}
pizza_eaten_vec <- tidy_pizza %>% 
  pull(pizzas_eaten)
```

**rename():** rename a column
```{r}
renamed_pizzas <- tidy_pizza %>% 
  rename(total_pizzas = pizzas_eaten)
```

**select():** select columns to retain and specify their order
```{r}
names_pizzas <- tidy_pizza %>% 
  select(name, pizzas_eaten)
```

**spread():** transform data from long to wide format
```{r}
# let's convert our 'tidy_data' back to wide format using spread()
back_to_wide <- tidy_pizza %>% 
  spread('year', 'pizzas_eaten')
```

**summarize():** calculate summary statistics
```{r}
pizza_summary <- tidy_pizza %>% 
  group_by(name) %>% 
  summarize(
    avg_pizzas = mean(pizzas_eaten), # feel free to substitute any summary stat function here!!
    max_pizza = max(pizzas_eaten),
    min_pizza = min(pizzas_eaten) # and add as many as you want to calculate!
  )
```

## **Now let's practice!**

### In addition to the tidyverse, we'll need to load a couple more packages:

```{r, message = FALSE, warning = FALSE}
library(here) # from the last R-Ladies Meetup!
library(lubridate) # to work more easily with dates
```

### Load the data: 

In celebration of this year's superbloom, we'll be exploring phenometric data of flowering California plants from the [USA-National Phenology Network](https://www.usanpn.org/home).

```{r, message = FALSE, warning = TRUE}
phenometrics_data <- read_csv(here::here("data","phenometrics_data.csv"))
```

Let's pretend we're trying to plan a getaway to the desert and want to time our trip so that we have the greatest chance of seeing fully bloomed plants. 

### Explore: 

```{r, eval = FALSE}
head(phenometrics_data) # view first 10 rows of data
tail(phenometrics_data) # view last 10 rows of data
str(phenometrics_data) # view data structure of df
```

This dataset has information on flowering plants for many states, but we're interested in California flowering plants. First, we'll filter only for California observations.

```{r}
ca_pheno <- phenometrics_data %>% 
  filter(State == "CA")
```

This is a bit more manageable (`r nrow(phenometrics_data)` as opposed to `r nrow(ca_pheno)`) but there are still a lot of columns that we don't necessarily need. Let's select the columns that we want.

```{r}
select_columns <- ca_pheno %>% 
  select(1:4, Genus, Species, Common_Name, Phenophase_Description, Year, Month)
```

To make this even more manageable, we can change the column names to something easier (i.e. shorter to type).

```{r}
rename_columns <- select_columns %>% 
  rename(Pheno = Phenophase_Description)
```

We can also combine the `Genus` and `Species` columns, because they shouldn't be separate.

```{r}
unite_columns <- rename_columns %>% 
  unite("Genus_Species", Genus, Species)
```

If you look at the `unite_columns` data frame, you'll see that there are `NA` values for some of the Year and Month entries. We can take out any rows with `NA` in either of these columns.

```{r}
remove_NA <- unite_columns %>% 
  drop_na(Year, Month)
```

Now, only the rows with complete year and month information are included. 

With this data set, we're ready to subset for desert species we're interested in. Let's say we're especially interested in Joshua trees (*Yucca brevifolia*).

```{r}
jt_sn <- remove_NA %>% 
  filter(Genus_Species == "Yucca_brevifolia")

jt_cn <- remove_NA %>% 
  filter(Common_Name == "Joshua tree")
```

Look at the `jt_cn` or `jt_sn` data frame. Since we want to time our trip to coincide with the highest occurrence of flowering Joshua trees, we can summarize the counts of each occurrence.

```{r}
jt_summarize <- jt_sn %>% 
  group_by(Month, Pheno) %>% 
  summarize(sum = n())

jt_tally <- jt_sn %>% 
  group_by(Month, Pheno) %>% 
  tally()
```

The last thing we need to do is set the levels for variables in the `pheno` column. We can do this with `mutate()` and `fct_relevel` in the `forcats` package.

```{r}
relevel <- jt_tally %>% 
  mutate(Pheno = fct_relevel(Pheno, c("Flowers or flower buds", "Open flowers")))
```

Like `group_by`, this doesn't change the structure of the data frame. It's a way of telling R, "There's an order to the objects in this character vector that I want you to remember."

Now, we can make a basic plot in `ggplot2` that puts month on the x-axis and count of each phenophase on the y-axis.

```{r}
ggplot(relevel, aes(x = Month, 
                       y = n, 
                       fill = Pheno)) +
  geom_col(position = "dodge")
```


### Wrangle:

(a) select relevant columns
(b) filter for only California data
(c) rename long-winded variable names
(d) remove missing values with NA

```{r}
ca_pheno <- site_phenometrics_data %>%
  select(1:5, Genus, Species, Common_Name, Phenophase_Description, Mean_First_Yes_Year, Mean_First_Yes_DOY) %>%
  filter(State == "CA")  %>%
  rename(pheno = Phenophase_Description,
         year = Mean_First_Yes_Year,
         day = Mean_First_Yes_DOY) %>%
  na_if(-9999)
```


